% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CAB.EBD_helpers.R
\name{EBD_WSI_fitness}
\alias{EBD_WSI_fitness}
\alias{fitness_function}
\alias{EBD.response_emission}
\alias{EBD.get_oc}
\alias{EBD.geometric_vi}
\alias{EBD.w_gaussian_mutation}
\alias{EBD.geometric_fitness_weights}
\title{McDowell's Evolutionary Behaviour Dynamics}
\usage{
EBD_WSI_fitness(max_phenotype, phenotypes, last_resp)

EBD.response_emission(preallocated_resp_index, tick, phenotypes)

EBD.get_oc(last_resp, oc_lower_bounds)

EBD.geometric_vi(inter_rft_interval, min_irt, time)

EBD.w_gaussian_mutation(tick, preallocated_mutant_change,
  preallocated_mutant_index, max_phenotype, phenotypes)

EBD.geometric_fitness_weights(fitness, parental_selection_p)
}
\description{
A list of functions in the \code{CAB} package's implementation of McDowell's Evolutionary Behaviour Dynamics. A list of lower level utility functions, such as for converting integers in base 10 to base 2 can be found in \link{EBD_utilities}. See \link{CAB.EBD} for more details.
}
\details{
Stuff.
}
\section{Fitness functions}{
{
    Computes the fitness of parents.
    \subsection{\code{EBD.wrapped_si_fitness}}{
        Wrapped specific individual fitness. The fitness value of a behaviour is \eqn{max( |i-k|, m - |i-k| )}, where \eqn{i} is the base 10 value of a behaviour in the population, \eqn{k} is the integer value of the reinforced behaviour, and \eqn{m} is the maximum base 10 value that a behaviour can take. It is wrapped because it is modularised around the domain \eqn{[0,m]}.
    }
    \subsection{Usage}{
        \code{EBD.wrapped_si_fitness( domain, phenotypes, last_resp )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{domain}}{A vector specifying the minimum and maximum base 10 values that a behaviour can take.}
            \item{\code{phenotypes}}{A numeric vector of behaviours in base 10.}
            \item{\code{}}{}
        }
    }
    \subsection{Value}{
        Returns a numeric vector of the same length as \code{phenotyes}. Indices will match.
    }
}
############################################################################
}

\section{Response emission functions}{
{
    Emits a response.
    \subsection{\code{EBD.response_emission}}{
        Emits a behaviour.
    }
    \subsection{Usage}{
        \code{EBD.response_emission( preallocated_resp_index, n_rft, time, rft_ticks, phenotypes )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{preallocated_resp_index}}{A numeric value.}
            \item{\code{n_rft}}{Number of reinforcement that occurred during a session.}
            \item{\code{time}}{Number of time ticks.}
            \item{\code{rft_ticks}}{Duration of reinforcment delivery.}
            \item{\code{phenotypes}}{A numeric vector of behaviours in base 10}.
        }
    }
    \subsection{Details}{
        The way that EBD is implemented in \code{CAB} is that the index of the responses are preallocated at the start of the simulation. This reduces the number of function calls to a random number generator and hence improves the speed of the model. The response index is recovered from the number of time ticks that the simulation has been run, \code{time}, accounting for the time ticks that were taken up by reinforcement deliveries.
    }
    \subsection{Value}{
        Returns a value selected from \code{phenotyes}.
    }
}
############################################################################
}

\section{Get the operant class}{
{
    From a behaviour in base 10, get the operant class.
    \subsection{\code{EBD.get_oc}}{
        Get the operant class
    }
    \subsection{Usage}{
        \code{EBD.get_oc( last_resp, oc_lower_bounds )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{last_resp}}{A numeric value.}
            \item{\code{oc_lower_bounds}}{Lower bounds of the operant classes.}
        }
    }
    \subsection{Value}{
        Returns the operant class that the last response belongs in.
    }
}
############################################################################
}

\section{Stock reinforcement schedule}{
{
    Common reinforcement schedules.
    \subsection{\code{EBD.geometric_vi}}{
        A VI schedule with geometrically distributed arranged inter-reinforcement intervals.
    }
    \subsection{Usage}{
        \code{EBD.geometric_vi( inter_rft_interval, min_irt, time )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{inter_rft_interval}}{Numeric. In real time.}
            \item{\code{min_irt}}{Minimum inter-response time, i.e. time ticks for the algorithm.}
            \item{\code{time}}{Numeric}
        }
    }
    \subsection{Value}{
        Generates a Geometrically distributed inter-reinforcement interval by doing a continuous to discrete transformation of the inter-rft-interval and adds the time to return the time at which food will be available.
    }
    \subsection{\code{EBD.shifted_geometric_vi}}{
        A VI schedule with shifted geometrically distributed arranged inter-reinforcement intervals.
    }
    \subsection{Usage}{
        \code{EBD.geometric_vi( inter_rft_interval, min_irt, time, shift )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{inter_rft_interval}}{Numeric. In real time.}
            \item{\code{min_irt}}{Minimum inter-response time, i.e. time ticks for the algorithm.}
            \item{\code{time}}{Numeric.}
            \item{\code{shift}}{Numeric. In real time. }
        }
    }
    \subsection{Value}{
        Generates a Geometrically distributed inter-reinforcement interval by doing a continuous to discrete transformation of the inter-rft-interval and adds the time to return the time at which food will be available.
    }
}
############################################################################
}

\section{Mutation}{
{
    Mutate behaviours in the population.
    \subsection{\code{EBD.w_gaussian_mutation}}{
        Mutate behaviours my resampling their phenotypes from a wrapped normal distribution.
    }
    \subsection{Usage}{
        \code{EBD.w_gaussian_mutation( tick, preallocated_mutant_change, preallocated_mutant_index, max_phenotype, phenotypes )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{tick}}{Numeric. The number of iterations of the algorithm.}
            \item{\code{preallocated_mutant_change}}{Matrix giving how much each phenotype changes.}
            \item{\code{preallocated_mutant_index}}{Matrix giving the phenotypes that will change.}
            \item{\code{max_phenotype}}{Numeric. The maximum phenotype value.}
            \item{\code{phenotypes}}{Vector.}
        }
    }
    \subsection{Details}{
        \code{preallocated_mutant_change} is a matrix that has rows the number of iterations to run the algorithm. Each column is the amount to change each phenotype to be mutated on that iteration.
        \code{preallocated_mutant_index} is a matrix of corresponding dimensions. Each column is the index of the phenotype to change.
    }
    \subsection{Value}{
        Returns a list containing the new phenotype values and the indices to which they belong.
    }
}
############################################################################
}

\section{Fitness weights}{
{
    Sampling weights for sampling fitness values.
    \subsection{\code{EBD.geometric_fitness_weights}}{
        Sampling weights from a geometric distribution
    }
    \subsection{Usage}{
        \code{EBD.geometric_fitness_weights( fitness, parental_selection_p )}
    }
    \subsection{Arguments}{
        \describe{
            \item{\code{fitness}}{Numeric vector of fitness values}
            \item{\code{parental_selection_p}}{Parameter for the geometric distribution}
        }
    }
    \subsection{Value}{
        Returns a vector of fitness weights.
    }
}
############################################################################
}

\seealso{
\link{CAB.EBD}
}
